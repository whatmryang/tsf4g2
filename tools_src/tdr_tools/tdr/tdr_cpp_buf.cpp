#include "tdr_cpp.h"
#include <iostream>
#include <string>

using std::cout;
using std::endl;
using std::string;

const char*
TTransCPP::bufHead[] = {
    "class TdrWriteBuf",
    "{",
    "    private:",
    "        char* beginPtr;",
    "        size_t position;",
    "        size_t length;",
    "",
    "    private:",
    "        bool needFree;",
    "",
    "    private:",
    "        void _free()",
    "        {",
    "            delete [] beginPtr;",
    "            needFree = false;",
    "            beginPtr = NULL;",
    "        }",
    "",
    "        void _set(char* ptr, size_t size)",
    "        {",
    "            beginPtr = ptr;",
    "            position = 0;",
    "            if (NULL == beginPtr)",
    "            {",
    "                length = 0;",
    "            } else",
    "            {",
    "                length = size;",
    "            }",
    "        }",
    "        void _reset()",
    "        {",
    "            beginPtr = NULL;",
    "            length = 0;",
    "            position = 0;",
    "        }",
    "",
    "    public:",
    "        TdrWriteBuf()",
    "        {",
    "            needFree = false;",
    "            _reset();",
    "        }",
    "",
    "        TdrWriteBuf(size_t size)",
    "        {",
    "            char* ptr = new(std::nothrow) char [size];",
    "            if (NULL != ptr)",
    "            {",
    "                needFree = true;",
    "            } else",
    "            {",
    "                needFree = false;",
    "            }",
    "            _set(ptr, size);",
    "        }",
    "",
    "        TdrWriteBuf(char* ptr, size_t size)",
    "        {",
    "            needFree = false;",
    "            _set(ptr, size);",
    "        }",
    "",
    "        ~TdrWriteBuf()",
    "        {",
    "            if (needFree)",
    "            {",
    "                _free();",
    "            }",
    "        }",
    "",
    "        void reset()",
    "        {",
    "            if (needFree)",
    "            {",
    "                _free();",
    "            }",
    "            _reset();",
    "        }",
    "",
    "        void set(char* ptr, size_t size)",
    "        {",
    "            if (needFree)",
    "            {",
    "                _free();",
    "            }",
    "            _set(ptr, size);",
    "        }",
    "",
    "        size_t getUsedSize() const",
    "        {",
    "            return position;",
    "        }",
    "",
    "        size_t getTotalSize() const",
    "        {",
    "            return length;",
    "        }",
    "",
    "        size_t getLeftSize() const",
    "        {",
    "            assert(position <= length);",
    "",
    "            return length - position;",
    "        }",
    "",
    "        const char* getBeginPtr() const",
    "        {",
    "            return beginPtr;",
    "        }",
    "",
    "        TdrError::ErrorType reserve(size_t gap)",
    "        {",
    "            assert(position <= length);",
    "",
    "            if (position > length)",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;",
    "            }",
    "",
    "            if (gap > (length - position))",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;",
    "            }",
    "",
    "            position += gap;",
    "",
    "            return TdrError::TDR_NO_ERROR;",
    "        }",
    "",
    "    public: /* print data visually */",
    "        TdrError::ErrorType vtextize(const char* format, va_list ap)",
    "        {",
    "            int ret = tdr_cpp_vsnprintf(beginPtr + position, length - position, format, ap);",
    "            if (0 > ret || (size_t)ret >= (length - position))",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;",
    "            }",
    "            position += ret;",
    "",
    "            return TdrError::TDR_NO_ERROR;",
    "        }",
    "",
    "        TdrError::ErrorType textize(const char* format, ...)",
    "        {",
    "            va_list ap;",
    "",
    "            va_start(ap, format);",
    "            int ret = tdr_cpp_vsnprintf(beginPtr + position, length - position, format, ap);",
    "            va_end(ap);",
    "            if (0 > ret || (size_t)ret >= (length - position))",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;",
    "            }",
    "            position += ret;",
    "",
    "            return TdrError::TDR_NO_ERROR;",
    "        }",
    "",
    "    public: /* write successively */",
    "        TdrError::ErrorType writeChar(const char src)",
    "        {",
    "            return writeUInt8(*(uint8_t*)&src);",
    "        }",
    "",
    "        /* this function is supposed to be called by visualize() directly or indiectly */",
    "        TdrError::ErrorType writeCharWithNull(const char src)",
    "        {",
    "            assert(position <= length);",
    "",
    "            if (sizeof(src) + 1 > (length - position))",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;",
    "            }",
    "",
    "            *(char*)(beginPtr + position) = src;",
    "            position += sizeof(src);",
    "",
    "            /* a null character is writed, but keeps position untouched */",
    "            *(char*)(beginPtr + position) = '\\0';",
    "",
    "            return TdrError::TDR_NO_ERROR;",
    "        }",
    "",
    "        TdrError::ErrorType writeUChar(const unsigned char src)",
    "        {",
    "            return writeUInt8(*(uint8_t*)&src);",
    "        }",
    "",
    "        TdrError::ErrorType writeInt8(const int8_t src)",
    "        {",
    "            return writeUInt8(*(uint8_t*)&src);",
    "        }",
    "",
    "        TdrError::ErrorType writeUInt8(const uint8_t src)",
    "        {",
    "            assert(position <= length);",
    "",
    "            if (sizeof(src) > (length - position))",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;",
    "            }",
    "",
    "            *(uint8_t*)(beginPtr + position) = src;",
    "            position += sizeof(src);",
    "",
    "            return TdrError::TDR_NO_ERROR;",
    "        }",
    "",
    "        TdrError::ErrorType writeInt16(const int16_t src)",
    "        {",
    "            return writeUInt16(*(uint16_t*)&src);",
    "        }",
    "",
    "        TdrError::ErrorType writeUInt16(const uint16_t src)",
    "        {",
    "            assert(position <= length);",
    "",
    "            if (sizeof(src) > (length - position))",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;",
    "            }",
    "",
    "            *(uint16_t*)(beginPtr + position) = tdr_cpp_hton16(src);",
    "            position += sizeof(src);",
    "",
    "            return TdrError::TDR_NO_ERROR;",
    "        }",
    "",
    "        TdrError::ErrorType writeInt32(const int32_t src)",
    "        {",
    "            return writeUInt32(*(uint32_t*)&src);",
    "        }",
    "",
    "        TdrError::ErrorType writeUInt32(const uint32_t src)",
    "        {",
    "            assert(position <= length);",
    "",
    "            if (sizeof(src) > (length - position))",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;",
    "            }",
    "",
    "            *(uint32_t*)(beginPtr + position) = tdr_cpp_hton32(src);",
    "            position += sizeof(src);",
    "",
    "            return TdrError::TDR_NO_ERROR;",
    "        }",
    "",
    "        TdrError::ErrorType writeInt64(const int64_t src)",
    "        {",
    "            return writeUInt64(*(uint64_t*)&src);",
    "        }",
    "",
    "        TdrError::ErrorType writeUInt64(const uint64_t src)",
    "        {",
    "            assert(position <= length);",
    "",
    "            if (sizeof(src) > (length - position))",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;",
    "            }",
    "",
    "            *(uint64_t*)(beginPtr + position) = tdr_cpp_hton64(src);",
    "            position += sizeof(src);",
    "",
    "            return TdrError::TDR_NO_ERROR;",
    "        }",
    "",
    "        TdrError::ErrorType writeFloat(const float src)",
    "        {",
    "            return writeUInt32(*(uint32_t*)&src);",
    "        }",
    "",
    "        TdrError::ErrorType writeDouble(const double src)",
    "        {",
    "            return writeUInt64(*(uint64_t*)&src);",
    "        }",
    "",
    "        TdrError::ErrorType writeBytes(const void* src, size_t count)",
    "        {",
    "            if (NULL == src)",
    "            {",
    "                return TdrError::TDR_ERR_ARG_POINTER_IS_NULL;",
    "            }",
    "",
    "            assert(position <= length);",
    "",
    "            if (count > (length - position))",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;",
    "            }",
    "",
    "            memmove(beginPtr + position, src, count);",
    "            position += count;",
    "",
    "            return TdrError::TDR_NO_ERROR;",
    "        }",
    "",
    "    public: /* write directly */",
    "        TdrError::ErrorType writeChar(const char src, size_t pos)",
    "        {",
    "            return writeUInt8((uint8_t)src, pos);",
    "        }",
    "",
    "        TdrError::ErrorType writeUChar(const unsigned char src, size_t pos)",
    "        {",
    "            return writeUInt8((uint8_t)src, pos);",
    "        }",
    "",
    "        TdrError::ErrorType writeInt8(const int8_t src, size_t pos)",
    "        {",
    "            return writeUInt8((uint8_t)src, pos);",
    "        }",
    "",
    "        TdrError::ErrorType writeUInt8(const uint8_t src, size_t pos)",
    "        {",
    "            assert(position <= length);",
    "",
    "            if (pos > length)",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;",
    "            }",
    "",
    "            if (sizeof(src) > (length - pos))",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;",
    "            }",
    "",
    "            *(uint8_t*)(beginPtr + pos) = src;",
    "",
    "            return TdrError::TDR_NO_ERROR;",
    "        }",
    "",
    "        TdrError::ErrorType writeInt16(const int16_t src, size_t pos)",
    "        {",
    "            return writeUInt16((uint16_t)src, pos);",
    "        }",
    "",
    "        TdrError::ErrorType writeUInt16(const uint16_t src, size_t pos)",
    "        {",
    "            assert(position <= length);",
    "",
    "            if (pos > length)",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;",
    "            }",
    "",
    "            if (sizeof(src) > (length - pos))",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;",
    "            }",
    "",
    "            *(uint16_t*)(beginPtr + pos) = tdr_cpp_hton16(src);",
    "",
    "            return TdrError::TDR_NO_ERROR;",
    "        }",
    "",
    "        TdrError::ErrorType writeInt32(const int32_t src, size_t pos)",
    "        {",
    "            return writeUInt32((uint32_t)src, pos);",
    "        }",
    "",
    "        TdrError::ErrorType writeUInt32(const uint32_t src, size_t pos)",
    "        {",
    "            assert(position <= length);",
    "",
    "            if (pos > length)",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;",
    "            }",
    "",
    "            if (sizeof(src) > (length - pos))",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;",
    "            }",
    "",
    "            *(uint32_t*)(beginPtr + pos) = tdr_cpp_hton32(src);",
    "",
    "            return TdrError::TDR_NO_ERROR;",
    "        }",
    "",
    "        TdrError::ErrorType writeInt64(const int64_t src, size_t pos)",
    "        {",
    "            return writeUInt64((uint64_t)src, pos);",
    "        }",
    "",
    "        TdrError::ErrorType writeUInt64(const uint64_t src, size_t pos)",
    "        {",
    "            assert(position <= length);",
    "",
    "            if (pos > length)",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;",
    "            }",
    "",
    "            if (sizeof(src) > (length - pos))",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;",
    "            }",
    "",
    "            *(uint64_t*)(beginPtr + pos) = tdr_cpp_hton64(src);",
    "",
    "            return TdrError::TDR_NO_ERROR;",
    "        }",
    "",
    "        TdrError::ErrorType writeFloat(const float src, size_t pos)",
    "        {",
    "            return writeUInt32(*(uint32_t*)&src, pos);",
    "        }",
    "",
    "        TdrError::ErrorType writeDouble(const double src, size_t pos)",
    "        {",
    "            return writeUInt64(*(uint64_t*)&src, pos);",
    "        }",
    "",
    "        TdrError::ErrorType writeBytes(const void* src, size_t count, size_t pos)",
    "        {",
    "            if (NULL == src)",
    "            {",
    "                return TdrError::TDR_ERR_ARG_POINTER_IS_NULL;",
    "            }",
    "",
    "            assert(position <= length);",
    "",
    "            if (count > (length - pos))",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;",
    "            }",
    "",
    "            memmove(beginPtr + pos, src, count);",
    "",
    "            return TdrError::TDR_NO_ERROR;",
    "        }",
    "};",
    "",
    "class TdrReadBuf",
    "{",
    "    private:",
    "        const char* beginPtr;",
    "        size_t position;",
    "        size_t length;",
    "",
    "    public:",
    "        TdrReadBuf()",
    "        {",
    "            reset();",
    "        }",
    "",
    "        TdrReadBuf(const char* ptr, size_t size)",
    "        {",
    "            set(ptr, size);",
    "        }",
    "",
    "        explicit TdrReadBuf(const TdrWriteBuf& writeBuf)",
    "        {",
    "            set(writeBuf.getBeginPtr(), writeBuf.getUsedSize());",
    "        }",
    "",
    "        void reset()",
    "        {",
    "            beginPtr = NULL;",
    "            length = 0;",
    "            position = 0;",
    "        }",
    "",
    "        void set(const char* ptr, size_t size)",
    "        {",
    "            beginPtr = ptr;",
    "            position = 0;",
    "            if (NULL == beginPtr)",
    "            {",
    "                length = 0;",
    "            } else",
    "            {",
    "                length = size;",
    "            }",
    "        }",
    "",
    "        size_t getUsedSize() const",
    "        {",
    "            return position;",
    "        }",
    "",
    "        size_t getTotalSize() const",
    "        {",
    "            return length;",
    "        }",
    "",
    "        size_t getLeftSize() const",
    "        {",
    "            assert(position <= length);",
    "",
    "            return length - position;",
    "        }",
    "",
    "        const char* getCurrentPtr() const",
    "        {",
    "            return beginPtr + position;",
    "        }",
    "",
    "        TdrError::ErrorType toHexStr(char* destBuf, size_t len, size_t* usedLen = NULL) const;",
    "",
    "        TdrError::ErrorType fromHexStr(const char* srcHexStr, size_t len, size_t* usedLen = NULL);",
    "",
    "    public: /* read successively */",
    "        TdrError::ErrorType readChar(char& dest)",
    "        {",
    "            return readUInt8(*(uint8_t*)&dest);",
    "        }",
    "",
    "        TdrError::ErrorType readUChar(unsigned char& dest)",
    "        {",
    "            return readUInt8(*(uint8_t*)&dest);",
    "        }",
    "",
    "        TdrError::ErrorType readInt8(int8_t& dest)",
    "        {",
    "            return readUInt8(*(uint8_t*)&dest);",
    "        }",
    "",
    "        TdrError::ErrorType readUInt8(uint8_t& dest)",
    "        {",
    "            assert(position <= length);",
    "",
    "            if (sizeof(dest) > (length - position))",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;",
    "            }",
    "",
    "            dest = *(uint8_t*)(beginPtr + position);",
    "            position += sizeof(dest);",
    "",
    "            return TdrError::TDR_NO_ERROR;",
    "        }",
    "",
    "        TdrError::ErrorType readInt16(int16_t& dest)",
    "        {",
    "            return readUInt16(*(uint16_t*)&dest);",
    "        }",
    "",
    "        TdrError::ErrorType readUInt16(uint16_t& dest)",
    "        {",
    "            assert(position <= length);",
    "",
    "            if (sizeof(dest) > (length - position))",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;",
    "            }",
    "",
    "            dest = tdr_cpp_ntoh16(*(uint16_t*)(beginPtr + position));",
    "            position += sizeof(dest);",
    "",
    "            return TdrError::TDR_NO_ERROR;",
    "        }",
    "",
    "        TdrError::ErrorType readInt32(int32_t& dest)",
    "        {",
    "            return readUInt32(*(uint32_t*)&dest);",
    "        }",
    "",
    "        TdrError::ErrorType readUInt32(uint32_t& dest)",
    "        {",
    "            assert(position <= length);",
    "",
    "            if (sizeof(dest) > (length - position))",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;",
    "            }",
    "",
    "            dest = tdr_cpp_ntoh32(*(uint32_t*)(beginPtr + position));",
    "            position += sizeof(dest);",
    "",
    "            return TdrError::TDR_NO_ERROR;",
    "        }",
    "",
    "        TdrError::ErrorType readInt64(int64_t& dest)",
    "        {",
    "            return readUInt64(*(uint64_t*)&dest);",
    "        }",
    "",
    "        TdrError::ErrorType readUInt64(uint64_t& dest)",
    "        {",
    "            assert(position <= length);",
    "",
    "            if (sizeof(dest) > (length - position))",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;",
    "            }",
    "",
    "            dest = tdr_cpp_ntoh64(*(uint64_t*)(beginPtr + position));",
    "            position += sizeof(dest);",
    "",
    "            return TdrError::TDR_NO_ERROR;",
    "        }",
    "",
    "        TdrError::ErrorType readFloat(float& dest)",
    "        {",
    "            return readUInt32(*(uint32_t*)&dest);",
    "        }",
    "",
    "        TdrError::ErrorType readDouble(double& dest)",
    "        {",
    "            return readUInt64(*(uint64_t*)&dest);",
    "        }",
    "",
    "        TdrError::ErrorType readBytes(void* dest, size_t count)",
    "        {",
    "            if (NULL == dest)",
    "            {",
    "                return TdrError::TDR_ERR_ARG_POINTER_IS_NULL;",
    "            }",
    "",
    "            assert(position <= length);",
    "",
    "            if (count > (length - position))",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;",
    "            }",
    "",
    "            memmove(dest, beginPtr + position, count);",
    "            position += count;",
    "",
    "            return TdrError::TDR_NO_ERROR;",
    "        }",
    "",
    "    public: /* read directly */",
    "        TdrError::ErrorType readChar(char& dest, size_t pos)",
    "        {",
    "            return readUInt8(*(uint8_t*)&dest, pos);",
    "        }",
    "",
    "        TdrError::ErrorType readUChar(unsigned char& dest, size_t pos)",
    "        {",
    "            return readUInt8(*(uint8_t*)&dest, pos);",
    "        }",
    "",
    "        TdrError::ErrorType readInt8(int8_t& dest, size_t pos)",
    "        {",
    "            return readUInt8(*(uint8_t*)&dest, pos);",
    "        }",
    "",
    "        TdrError::ErrorType readUInt8(uint8_t& dest, size_t pos)",
    "        {",
    "            assert(position <= length);",
    "",
    "            if (pos > length)",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;",
    "            }",
    "",
    "            if (sizeof(dest) > (length - pos))",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;",
    "            }",
    "",
    "            dest = *(uint8_t*)(beginPtr + pos);",
    "",
    "            return TdrError::TDR_NO_ERROR;",
    "        }",
    "",
    "        TdrError::ErrorType readInt16(int16_t& dest, size_t pos)",
    "        {",
    "            return readUInt16(*(uint16_t*)&dest, pos);",
    "        }",
    "",
    "        TdrError::ErrorType readUInt16(uint16_t& dest, size_t pos)",
    "        {",
    "            assert(position <= length);",
    "",
    "            if (pos > length)",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;",
    "            }",
    "",
    "            if (sizeof(dest) > (length - pos))",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;",
    "            }",
    "",
    "            dest = tdr_cpp_ntoh16(*(uint16_t*)(beginPtr + pos));",
    "",
    "            return TdrError::TDR_NO_ERROR;",
    "        }",
    "",
    "        TdrError::ErrorType readInt32(int32_t& dest, size_t pos)",
    "        {",
    "            return readUInt32(*(uint32_t*)&dest, pos);",
    "        }",
    "",
    "        TdrError::ErrorType readUInt32(uint32_t& dest, size_t pos)",
    "        {",
    "            assert(position <= length);",
    "",
    "            if (pos > length)",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;",
    "            }",
    "",
    "            if (sizeof(dest) > (length - pos))",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;",
    "            }",
    "",
    "            dest = tdr_cpp_ntoh32(*(uint32_t*)(beginPtr + pos));",
    "",
    "            return TdrError::TDR_NO_ERROR;",
    "        }",
    "",
    "        TdrError::ErrorType readInt64(int64_t& dest, size_t pos)",
    "        {",
    "            return readUInt64(*(uint64_t*)&dest, pos);",
    "        }",
    "",
    "        TdrError::ErrorType readUInt64(uint64_t& dest, size_t pos)",
    "        {",
    "            assert(position <= length);",
    "",
    "            if (pos > length)",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;",
    "            }",
    "",
    "            if (sizeof(dest) > (length - pos))",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;",
    "            }",
    "",
    "            dest = tdr_cpp_ntoh64(*(uint64_t*)(beginPtr + pos));",
    "",
    "            return TdrError::TDR_NO_ERROR;",
    "        }",
    "",
    "        TdrError::ErrorType readFloat(float& dest, size_t pos)",
    "        {",
    "            return readUInt32(*(uint32_t*)&dest, pos);",
    "        }",
    "",
    "        TdrError::ErrorType readDouble(double& dest, size_t pos)",
    "        {",
    "            return readUInt64(*(uint64_t*)&dest, pos);",
    "        }",
    "",
    "        TdrError::ErrorType readBytes(void* dest, size_t count, size_t pos)",
    "        {",
    "            if (NULL == dest)",
    "            {",
    "                return TdrError::TDR_ERR_ARG_POINTER_IS_NULL;",
    "            }",
    "",
    "            assert(position <= length);",
    "",
    "            if (count > (length - pos))",
    "            {",
    "                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;",
    "            }",
    "",
    "            memmove(dest, beginPtr + pos, count);",
    "",
    "            return TdrError::TDR_NO_ERROR;",
    "        }",
    "};",
    "",
    "template<typename TYPE>",
    "TdrError::ErrorType",
    "restoreFromHexStr(TYPE& data, const char* srcHexStr, size_t len, size_t* usedLen = NULL)",
    "{",
    "    if (NULL == srcHexStr)",
    "    {",
    "        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;",
    "    }",
    "",
    "    return TdrReadBuf((char*)&data, sizeof(data)).fromHexStr(srcHexStr, len, usedLen);",
    "}",
};

const char*
TTransCPP::bufCpp[] = {
    "TdrError::ErrorType",
    "TdrReadBuf::toHexStr(char* destBuf, size_t len, size_t* usedLen) const",
    "{",
    "    assert (NULL != destBuf);",
    "",
    "    static char hexTab[16] =",
    "    {",
    "        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'",
    "    };",
    "",
    "    assert(position <= length);",
    "",
    "    const size_t dataLen = length - position;",
    "    const size_t hexDatLen = dataLen * 2 + 1;",
    "    if (len < hexDatLen)",
    "    {",
    "        return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;",
    "    }",
    "",
    "    size_t hexBufPos = 0;",
    "    for (size_t i = 0; i < dataLen; i++)",
    "    {",
    "        unsigned char low  = *(beginPtr + position + i) & 0X0F;",
    "        unsigned char high = *(unsigned char*)(beginPtr + position + i) >> 4;",
    "        destBuf[hexBufPos++] = hexTab[high];",
    "        destBuf[hexBufPos++] = hexTab[low];",
    "    }",
    "    destBuf[hexBufPos] = '\\0';",
    "    if (NULL != usedLen)",
    "    {",
    "        *usedLen = hexDatLen;",
    "    }",
    "",
    "    return TdrError::TDR_NO_ERROR;",
    "}",
    "",
    "TdrError::ErrorType",
    "TdrReadBuf::fromHexStr(const char* srcHexStr, size_t len, size_t* usedLen)",
    "{",
    "    assert(NULL != srcHexStr);",
    "",
    "    if (0 != len % 2)",
    "    {",
    "        return TdrError::TDR_ERR_INVALID_HEX_STR_LEN;",
    "    }",
    "",
    "    assert(position <= length);",
    "",
    "    const size_t available = length - position;",
    "    const size_t capacity = 2 * available;",
    "",
    "    const size_t _usedLen = (capacity <= len)? capacity : len;",
    "",
    "    size_t pos = position;",
    "    for (size_t i = 0; i < _usedLen; i += 2)",
    "    {",
    "        int highChar = srcHexStr[i];",
    "        int lowChar  = srcHexStr[i + 1];",
    "",
    "        if (!isxdigit(highChar) || !isxdigit(lowChar))",
    "        {",
    "            if (NULL != usedLen)",
    "            {",
    "                *usedLen = 2 * i;",
    "            }",
    "            return TdrError::TDR_ERR_INVALID_HEX_STR_FORMAT;",
    "        }",
    "",
    "        unsigned char value = 0;",
    "",
    "        if (isdigit(highChar))",
    "        {",
    "            value |= ((highChar - '0') << 4);",
    "        } else if (islower(highChar))",
    "        {",
    "            value |= ((highChar - 'a' + 10) << 4);",
    "        } else",
    "        {",
    "            value |= ((highChar - 'A' + 10) << 4);",
    "        }",
    "",
    "        if (isdigit(lowChar))",
    "        {",
    "            value |= (lowChar - '0');",
    "        } else if (islower(lowChar))",
    "        {",
    "            value |= (lowChar - 'a' + 10);",
    "        } else",
    "        {",
    "            value |= (lowChar - 'A' + 10);",
    "        }",
    "",
    "        *(unsigned char*)(beginPtr + pos++) = value;",
    "    }",
    "",
    "    length = position + _usedLen / 2;",
    "    if (NULL != usedLen)",
    "    {",
    "        *usedLen = _usedLen;",
    "    }",
    "",
    "    return TdrError::TDR_NO_ERROR;",
    "}",
};

void
TTransCPP::makeTdrBuf()
{
    DEFINE_CONTAINER();

    APPEND_CONTAINER_HEAD("#ifndef _TDR_BUF_H_");
    APPEND_CONTAINER_HEAD("#define _TDR_BUF_H_");
    APPEND_CONTAINER_HEAD("");

    APPEND_CONTAINER_HEAD("#include <new>");
    APPEND_CONTAINER_HEAD("#include <cstdio>");
    APPEND_CONTAINER_HEAD("#include <cassert>");
    APPEND_CONTAINER_HEAD("#include <cstring>");
    APPEND_CONTAINER_HEAD("#include <cstdarg>");
    APPEND_CONTAINER_HEAD("");
    APPEND_CONTAINER_HEAD("#include \"TdrPal.h\"");
    APPEND_CONTAINER_HEAD("#include \"TdrError.h\"");
    APPEND_CONTAINER_HEAD("");

    APPEND_CONTAINER_CPP("#include \"TdrBuf.h\"");
    APPEND_CONTAINER_CPP("");
    APPEND_CONTAINER_CPP("#include <cctype>");
    APPEND_CONTAINER_CPP("");

    APPEND_CONTAINER("namespace tsf4g_tdr");
    APPEND_CONTAINER("{");
    APPEND_CONTAINER("");
    APPEND_CONTAINER("");

    loadCodeRes(0, headLines, bufHead, sizeof(TTransCPP::bufHead)/sizeof(TTransCPP::bufHead[0]));
    loadCodeRes(0, cppLines, bufCpp, sizeof(TTransCPP::bufCpp)/sizeof(TTransCPP::bufCpp[0]));

    APPEND_CONTAINER("");
    APPEND_CONTAINER("}");

    APPEND_CONTAINER_HEAD("#endif");

    OUTPUT_CONTAINER_NOMETA(string("TdrBuf.h"), string("TdrBuf.cpp"));
}
