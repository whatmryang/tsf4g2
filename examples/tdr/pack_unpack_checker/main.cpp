#include <iostream>
#include <cstring>

#include "option.h"
#include "TdrBuf.h"
#include "TdrTypeUtil.h"

#include "./checker.h"


using std::cout;
using std::endl;
using tsf4g_tdr::TdrTypeUtil;

/* step 1 */
/* 步骤 1 */
/* using namespace defined in .cpp file generated by TDR */
/* 使用TDR工具生成的文件中定义的 namespace */
using namespace net;


/* declaration */
template <typename PKG_TYPE>
int pack_unpack(const Option& option, const char* data, size_t size);

template <typename PKG_TYPE>
int pack(const char* data, size_t size);

template <typename PKG_TYPE>
int unpack(const char* data, size_t size);

int load_data(const Option& option, FILE* src, char*& data, size_t& size);

int main(int argc, char* argv[])
{
    int ret = 0;

    Option option;
    ret = option.parse(argc, argv);
    if (0 > ret) {
        return ret;
    }

    /* check parameters */
    FILE* dataSrc = fopen(option.srcDataFile, "rb");
    if (NULL == dataSrc) {
        cout << "Error: failed to open file '" << option.srcDataFile << "' to read" << endl;

        return -1;
    }

    /* read data from file */
    char* data = NULL;
    size_t size = 0;
    ret = load_data(option, dataSrc, data, size);
    if (0 != ret) {
        cout << "Error: failed to load data from file '" << option.srcDataFile << "'" << endl;

        fclose(dataSrc);
        return -1;
    }

    /* step 2 */
    /* 步骤 2 */
    /* subsitue Pkg with your struct type defined in pack_unpack_checker.h */
    /* 使用你关心的、定义在文件 pack_unpack_checker.h 中的 struct 类型替换 Pkg */
    ret = pack_unpack<Pkg>(option, data, size);

    free(data);
    fclose(dataSrc);

    return ret;
}

template <typename PKG_TYPE>
int pack_unpack(const Option& option, const char* data, size_t size)
{
    if (Option::OPER_HTON == option.enID) {
        return pack<PKG_TYPE>(data, size);
    } else {
        return unpack<PKG_TYPE>(data, size);
    }
}


template <typename PKG_TYPE>
int pack(const char* data, size_t size)
{
    assert(NULL != data);
    assert(0 < size);


    if (size < sizeof(PKG_TYPE)) {
        cout << "Error: binary-data does not cover a object" << endl;

        return -1;
    }

    PKG_TYPE* pkg = (PKG_TYPE*)data;

    /* print pkg */
    /* 打印 pkg */
    static char visualBuffer[10 * sizeof(PKG_TYPE)];
    TdrError::ErrorType iRet = pkg->visualize(visualBuffer, sizeof(visualBuffer));
    if (TdrError::TDR_NO_ERROR != iRet) {
        cout << "Error: failed to visualize host pkg, for: "
            << TdrError::getErrorString(iRet) << endl;

        return -1;
    }
    cout << "pkg:" << endl;
    cout << visualBuffer << endl;

    /* pack pkg */
    /* 打包 pkg */
    static char packedBuffer[10 * sizeof(PKG_TYPE)];
    size_t packedSize = 0;
    iRet = pkg->pack(packedBuffer, sizeof(packedBuffer), &packedSize);
    if (TdrError::TDR_NO_ERROR != iRet) {
        cout << "Error: failed to pack, for: " << TdrError::getErrorString(iRet) << endl;
    } else {
        cout << endl << "******** pack successful ********" << endl << endl;
    }

    /* print binary data generated by pack with hex-format */
    /* 以 16 进制的形式打印出 pack 生成的二进制数据 */
    static char rawHexBuf[10 * sizeof(PKG_TYPE)];
    static TdrReadBuf hexBuf(packedBuffer, packedSize);
    iRet = hexBuf.toHexStr(rawHexBuf, sizeof(rawHexBuf));
    if (TdrError::TDR_NO_ERROR != iRet) {
        cout << "Error: failed to construct hex-string from binary data, for: "
            << TdrError::getErrorString(iRet) << endl;

        return -1;
    }
    cout << "[hex-content generated by pack]:" << endl;
    cout << rawHexBuf << endl << endl;

    return 0;
}

template <typename PKG_TYPE>
int unpack(const char* data, size_t size)
{
    TdrReadBuf netBuf(data, size);

    /* unpack pkg */
    /* 解包 pkg */
    PKG_TYPE pkg;
    TdrError::ErrorType iRet = pkg.unpack(netBuf);
    if (TdrError::TDR_NO_ERROR != iRet) {
        cout << "Error: failed to unpack, for: " << TdrError::getErrorString(iRet) << endl;
        cout << endl << "********   unpack failed   ********" << endl << endl;

        if (netBuf.getUsedSize() == 0) {

            return -1;
        }
    } else {
        cout << endl << "******** unpack successful ********" << endl << endl;
    }

    /* print pkg */
    /* 打印 pkg */
    static char visualBuffer[10 * sizeof(PKG_TYPE)];
    iRet = pkg.visualize(visualBuffer, sizeof(visualBuffer));
    if (TdrError::TDR_NO_ERROR != iRet) {
        cout << "Error: failed to visualize host pkg, for: "
            << TdrError::getErrorString(iRet) << endl;
    }
    cout << "pkg:" << endl;
    cout << visualBuffer << endl;

    return 0;
}

/* load binary data from src and return it by <data, size> */
/* if data stored in src is hex-string, convert it to binary data */
int load_data(const Option& option, FILE* src, char*& data, size_t& size)
{
    assert(NULL != src);


    int ret = fseek(src, 0, SEEK_END);
    if (0 != ret) {
        cout << "Error: fseek failed" << endl;

        return -1;
    }

    long dataLen = ftell(src);
    if (0 > dataLen) {
        cout << "Error: ftell failed" << endl;

        return -1;
    } else if (0 == dataLen) {
        cout << "Error: file '" << option.srcDataFile << "' is empty" << endl;

        return -1;
    }

    ret = fseek(src, 0, SEEK_SET);
    if (0 != ret) {
        cout << "Error: fseek failed" << endl;

        return -1;
    }

    char* binaryData = (char*)malloc((size_t)dataLen);
    if (NULL == binaryData) {
        cout << "Error: failed to malloc memory" << endl;

        return -1;
    }

    size = fread(binaryData, 1, (size_t)dataLen, src);
    if (size < (size_t)dataLen) {
        cout << "Error: failed to read from file '" << option.srcDataFile << "'" << endl;

        free(binaryData);
        return -1;
    }

    if (Option::TYPE_HEX_STR != option.srcDataType) {
        data = binaryData;
        return 0;
    } else {
        char* hexData = binaryData;
        dataLen = dataLen - dataLen%2;
        binaryData = (char*)malloc((size_t)dataLen/2);
        if (NULL == binaryData) {
            cout << "Error: failed to malloc memory" << endl;

            free(hexData);
            return -1;
        } else {
            TdrReadBuf binaryBuf(binaryData, (size_t)dataLen/2);
            TdrError::ErrorType tdrRet = binaryBuf.fromHexStr(hexData, (size_t)dataLen);
            if (TdrError::TDR_NO_ERROR != tdrRet) {
                cout << "Error: failed to construct net data from hex-string, for: "
                    << TdrError::getErrorString(tdrRet) << endl;

                free(binaryData);
                free(hexData);

                return -1;
            } else {
                data = binaryData;
                size = dataLen/2;
                free(hexData);

                return 0;
            }
        }
    }
}
