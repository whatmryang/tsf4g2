#ifndef _TSM_TDR_I_H_
#define _TSM_TDR_I_H_
//============================================================================
// @Id:       $Id: tsm_tdr_i.h 13779 2010-09-26 02:27:10Z tomaswang $
// @Author:   $Author: tomaswang $
// @Date:     $Date:: 2010-09-26 10:27:10 +0800 #$
// @Revision: $Revision: 13779 $
// @HeadURL:  $HeadURL:: https://tc-svn.tencent.com/ied/ied_tsf4g_rep/tsf4g_#$
//----------------------------------------------------------------------------


#include <sys/types.h>

#include "tdr/tdr_metalib_init.h"
#include "tsm_index.h"
#include "err_stack.h"
#include "tsm_base.h"
#include "tsm_uri_i.h"
#include "tsm_head.h"


//----------------------------------------------------------------------------
// TSM_URI 是一个描述工具，可以用来描述位置，查询，定义等
// 对于 Tdr方式的共享内存管理来说，有必要定义 TsmUriTdr的格式和内部表示
// 
// TSM URI for TDR 格式:
//     tsm-data://<bussi-id>/<proc-name>:<proc-id>/<func-name>/<...>
//         这是第一种格式，叫做 data 格式
// 
// <1> bussi_id           业务id，例如: 大碗菜；QQ幻想；QQ飞车的内部标识
// <2> process_name       进程名，例如: torm_server
// <3> process_id         进程号，相同进程名的不同实例
//                        如果不想区分进程，这个位置可以为空
// <4> function_name      功能名，例如: config, status
// <5> ...                后面的字段可以自定义
// 
//     tsm-meta://<bussi-id>/<lib>:<ver>:<build_ver>/<meta>:<ver>:<size>/<...>
//         这是第二种格式，叫做 meta 格式
//         其中
// <1> bussi_id           业务id，例如: 大碗菜；QQ幻想；QQ飞车的内部标识
// <2> lib                是 metalib名字
// <3> ver                是 metalib版本号
// <4> build_ver          是 metalib的 build版本号
// <5> meta               是 meta 的名字
// <6> ver                是 meta 的版本
// <7> size               是 meta 的尺寸
// <8> ...                后面的字段可以自定义
//     如果只有 tsm-meta://<bussi-id>/<lib-name>/ 这代表一个 lib
// 
// 两种格式中，任何<>括起来的字段都可以换成?(表示查询) 或者 *(表示不关心)
//     一个查询 URI有且只有一个 ?字段，可以有 0个或多个 *字段
//     一个查询 URI最后面的 *字段可以省略不写
//         例如想查询系统中有哪些 bussiness可以直接用 tsm-data://?
//----------------------------------------------------------------------------


//============================================================================
// API 一共要提供六种功能，分别是
//     1 错误处理
//     2 将某个 data 和某个 meta 绑定，或者设定一个 data 的尺寸
//     3 将 data 或者 meta 发布到共享内存中
//     4 从共享内存中获得 data 指针
//     5 将 data 从共享内存中删除
//     6 取得共享内存中的 data 或者 meta 内容
//       查询或遍历共享内存中已经存在的 data 或者 meta
//----------------------------------------------------------------------------


//============================================================================
// 0 句柄相关 API
//----------------------------------------------------------------------------
// 为了使 API功能清晰，所有的 API都和一个句柄相关联
//     这样 API可以用句柄来暂存数据
//     每次调用 API之前，相关句柄中的错误信息将被清除
// 
//----------------------------------------------------------------------------
typedef struct
{
    int           iType;        // 当前行的类型
    int           iIndex;       // 行的序号 [0, iRet)
    size_t        iObj;         // TsmObj的偏移
    TsmUri        stMeta;       // 当前行的 URI
    TsmUri        stData;       // 当前行的 URI
    TsmObjPtr     stMetaPtr;    // 当前行代表的 Lib指针，为 NULL 表示没有 Lib
    TsmObjPtr     stDataPtr;    // 当前行代表的数据指针，为 NULL 表示没有数据
    LPTDRMETALIB  pstMeta;      // 指向 metalib 的指针
    void         *pstData;      // 指向 data 的指针
    size_t        iSize;        // 当前行代表的数据尺寸，[pData, pData+iSize)
} TsmTdrRow;

typedef struct
{
    int        iCount;          // 结果集中的行数
    TsmTdrRow *pstCurrent;      // 指向当前行的指针
    TsmTdrRow *pstHead;         // 指向第一行的指针
} TsmTdrResult;

typedef struct
{
    int           iMagic;               // 指示句柄是否生效
    TsmIndex     *pstIndex;             // 指向共享内存索引区的指针
    TsmUri        stMeta;               // Meta Uri
    TsmUri        stData;               // Data Uri
    TsmTdrResult *pstResult;            // 
} TsmTdrHandle;

//----------------------------------------------------------------------------
//  设置四个变量，以后用这些变量控制 index
//      a_iLibHash      每一条 Lib记录，需要多少个哈希结点做索引
//      a_iLibCap       每个 Inxex中最多可以容纳多少条 Lib记录
//      a_iUriHash      每一条 Uri记录，需要多少个哈希结点做索引
//      a_iUriCap       每个 Inxex中最多可以容纳多少条 Uri记录
//  返回的变量表示，有效的设置个数
//      设置的值和系统中的值一样，看做无效
//  PS: 这四个变量，只能在 tsm_index_init  之前设置
//      否则使用缺省值，缺省值在 tsm_base  中单件初始化函数中设置
//----------------------------------------------------------------------------
/*
int tsm_tdr_base_set_i(int a_iLibHash,
                       int a_iLibCap,
                       int a_iUriHash,
                       int a_iUriCap);
*/
#define tsm_tdr_base_set_i tsm_index_base_set

//----------------------------------------------------------------------------
// 函数 open 和 init 是一样的，返回一个 TsmTdrHandle 句柄
// 如果没有空间分配新句柄，则返回TSM_TDR_HANDLE_NULL
//     否则返回 tagTsmTdrHandle数组的一个索引
//----------------------------------------------------------------------------
int tsm_tdr_open_i(TsmTdrHandle **a_pHandle);
int tsm_tdr_init_i(TsmTdrHandle  *a_pHandle);

//----------------------------------------------------------------------------
// 函数关闭一个 TsmTdrHandle 句柄
//----------------------------------------------------------------------------
int tsm_tdr_close_i  (TsmTdrHandle **a_pHandle);
int tsm_tdr_destroy_i(TsmTdrHandle  *a_pHandle);

//----------------------------------------------------------------------------
// 加锁
//----------------------------------------------------------------------------
int tsm_tdr_lock(TsmTdrHandle *a_pHandle, int a_iReadOnly);

//----------------------------------------------------------------------------
// 解锁
//----------------------------------------------------------------------------
int tsm_tdr_unlock(TsmTdrHandle *a_pHandle);

//============================================================================
// 1 错误处理相关 API
//----------------------------------------------------------------------------
// 返回上一个 API执行过程中的错误栈
//----------------------------------------------------------------------------
TErrorSet *tsm_tdr_error_i(TsmTdrHandle *a_pHandle);


//============================================================================
// 2 绑定相关 API
//----------------------------------------------------------------------------
// 一个句柄上可以绑定三种不同的变量
//     1  data 格式的 URI
//     2  meta 格式的 URI
//     3  data 格式的 URI指定的结构体尺寸
// 这三种变量单独存在，但是互相之间有一定的约束
//----------------------------------------------------------------------------
// 这个 API可以
//     1 将一个 data 格式的 URI绑定到句柄上
//     2 从句柄上清除一个 data 格式 (pszUri是 tsm-data://...)
// 成功返回 0，否则返回错误代码
// 如果成功返回，同时系统中已经存在这个 uri
//     则这个 api会同时更新句柄的 meta 绑定和 size 绑定
//     否则，清空 meta 绑定和清零 size 绑定
//----------------------------------------------------------------------------
int tsm_tdr_bind_data_i(TsmTdrHandle *a_pHandle, const char *a_pszUri);

//----------------------------------------------------------------------------
// 这个 API可以将一个 meta 格式的 URI绑定到句柄上
//     pszUri是具体的 meta 格式的 URI
// 调用这个 api之前，需要满足几个条件
//     参数所指向的 meta 在系统中已经存在，或者可以自动载入
//     句柄的 data 绑定不能为空
//     句柄的 meta 绑定必须为空或者与参数相同
//     句柄的 size 绑定为零，或者等于待绑定的 meta 中提取的尺寸
// 成功返回 0，否则返回错误代码
// 如果成功返回，则这个 api会更新 size 绑定到 meta 中提取的尺寸
//----------------------------------------------------------------------------
int tsm_tdr_bind_meta_i(TsmTdrHandle *a_pHandle, const char *a_pszUri);

//----------------------------------------------------------------------------
// 这个 API可以将一个尺寸信息绑定到句柄上
// 调用这个 api之前，需要满足几个条件
//     句柄的 data 绑定不能为空
//     句柄的 meta 绑定必须为空
//     句柄的 size 绑定为零，或者与参数相同
// 成功返回 0，否则返回错误代码
//----------------------------------------------------------------------------
int tsm_tdr_bind_size_i(TsmTdrHandle *a_pHandle, size_t a_iSize);

//----------------------------------------------------------------------------
// 取得句柄上绑定过的 URI和结构体尺寸
//----------------------------------------------------------------------------
const char *tsm_tdr_bind_get_data_i(TsmTdrHandle *a_pHandle);
const char *tsm_tdr_bind_get_meta_i(TsmTdrHandle *a_pHandle);
size_t      tsm_tdr_bind_get_size_i(TsmTdrHandle *a_pHandle);


//============================================================================
// 3 发布相关 API
//----------------------------------------------------------------------------
// 这个 API可以发布 data 到系统中
// 调用这个 api之前，需要满足几个条件
//     句柄的 data 绑定不能为空
//     句柄的 size 绑定不能为零
// 参数 a_pData指向待发布的数据，例如: (struct tagUserData *)
//      a_pData数据长度为句柄的 size 绑定
//      a_iFlag标志，这个参数的含义是系统调用 open 的子集
//             包括 O_CREAT, O_EXCL, O_NONBLOCK or O_NDELAY
// 成功返回 0，否则返回错误代码
//----------------------------------------------------------------------------
int tsm_tdr_load_data_i(TsmTdrHandle *a_pHandle, void *a_pData, int a_iFlag);

//----------------------------------------------------------------------------
// 发布 metalib到系统中
//     a_pData   是 LPTDRMETALIB 指向一个 metalib
// 成功返回 0，否则返回错误代码
//----------------------------------------------------------------------------
int tsm_tdr_load_meta_i(TsmTdrHandle *a_pHandle,
                        LPTDRMETALIB  a_pData,
                        int           a_iBid);

//----------------------------------------------------------------------------
// 将一个存在于文件中的 metalib发布到系统中
//     a_pszPath 是一个路径，是一个 tdr文件
// 成功返回 0，否则返回错误代码
//----------------------------------------------------------------------------
int tsm_tdr_load_meta_file_i(TsmTdrHandle *a_pHandle,
                             const char   *a_pszPath,
                             int           a_iBid);


//============================================================================
// 4 数据取得相关 API
//----------------------------------------------------------------------------
// 这个 API返回句柄中绑定的 data 格式 URI所指向的，在共享内存中的指针结构
//      a_iFlag标志，这个参数的含义是系统调用 open 的子集
//             包括 O_CREAT, O_EXCL, O_NONBLOCK or O_NDELAY
// 返回
//      NULL            代表出错
//      (TsmObjPtr *)-1 a_iFlag 的条件不满足
// 其他返回代表成功
//----------------------------------------------------------------------------
TsmObjPtr *tsm_tdr_ptr_i(TsmTdrHandle *a_pHandle, int a_iFlag);

//----------------------------------------------------------------------------
// 这个 API返回 PTR所指向的，在共享内存中的结构
//      a_iReadOnly  表示如何打开操作取得的空间
// 返回 NULL 代表失败，否则是指向结构的指针
//----------------------------------------------------------------------------
void *tsm_tdr_at_i(TsmObjPtr *a_pPtr, int a_iReadOnly);

//----------------------------------------------------------------------------
// 这个 API释放 tsm_tdr_at 返回的指针
//     这个函数调用之后，不再保证那个指针指向正确的结构体
//     内部实现主要是对共享内存数据解锁的过程
//     用户程序应该成对地使用 at, dt 并且在 at 之后尽快地使用 dt (即使不加锁)
//----------------------------------------------------------------------------
int tsm_tdr_dt_i(void *a_pAt);


//============================================================================
// 5 查询相关 API
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// 执行一个查询
//     a_pszUri    待查询的 URI
// 如果成功返回 0，否则非零
//----------------------------------------------------------------------------
int tsm_tdr_query_i(TsmTdrHandle *a_pHandle, const char *a_pszUri);

//----------------------------------------------------------------------------
// 返回上一个 query查询的结果集
//     一次查询之后，如果重复调用此函数，则除第一次外，后面都返回 NULL
// 如果成功返回结果集指针，否则返回 NULL
//----------------------------------------------------------------------------
TsmTdrResult *tsm_tdr_store_result_i(TsmTdrHandle *a_pHandle);

//----------------------------------------------------------------------------
// 返回结果集中记录的行数
// 失败返回-1，否则返回不小于零的行数
//----------------------------------------------------------------------------
int tsm_tdr_num_rows_i(TsmTdrResult *a_pResult);

//----------------------------------------------------------------------------
// 在结果集中定位一条记录
//     a_iIndex  是结果集中记录的索引，范围为 [0, num_rows)
//----------------------------------------------------------------------------
int tsm_tdr_data_seek_i(TsmTdrResult *a_pResult, int a_iIndex);

//----------------------------------------------------------------------------
// 从结果集中返回一行
//     如果已经到达结尾，返回 NULL
//----------------------------------------------------------------------------
TsmTdrRow *tsm_tdr_fetch_row_i(TsmTdrResult *a_pResult);

//----------------------------------------------------------------------------
// 释放一个结果集
//----------------------------------------------------------------------------
int tsm_tdr_free_result_i(TsmTdrResult *a_pResult);

//----------------------------------------------------------------------------
// 从一行记录中提取字段的宏
//----------------------------------------------------------------------------
int         tsm_tdr_row_unlink_i  (TsmTdrRow *a_pRow, TsmTdrHandle *a_pHandle);

int         tsm_tdr_row_type_i    (TsmTdrRow *a_pRow);
int         tsm_tdr_row_is_data_i (TsmTdrRow *a_pRow);
int         tsm_tdr_row_is_meta_i (TsmTdrRow *a_pRow);

const char *tsm_tdr_row_meta_uri_i(TsmTdrRow *a_pRow);
const char *tsm_tdr_row_uri_i     (TsmTdrRow *a_pRow);
TsmObjPtr  *tsm_tdr_row_meta_ptr_i(TsmTdrRow *a_pRow);
TsmObjPtr  *tsm_tdr_row_data_ptr_i(TsmTdrRow *a_pRow);
LPTDRMETA   tsm_tdr_row_meta_i    (TsmTdrRow *a_pRow);
void       *tsm_tdr_row_data_i    (TsmTdrRow *a_pRow, int a_iReadOnly);
size_t      tsm_tdr_row_size_i    (TsmTdrRow *a_pRow);

//----------------------------------------------------------------------------
// 有时，开发者明确地知道查询的返回只有一行
//     这时可以用简化的 api返回这一行
// 下一个查询之前，返回的行总是有效的
// 返回 NULL ，表示没有找到或者找到多行，否则返回唯一的一行
//----------------------------------------------------------------------------
TsmTdrRow *tsm_tdr_row_only_i(TsmTdrHandle *a_pHandle);

//----------------------------------------------------------------------------
// 有时，开发者只想处理结果集中的任意一行
//     这时可以用简化的 api返回这一行
// 下一个查询之前，返回的行总是有效的
// 返回 NULL ，表示没有一行都没有找到，否则返回找到的某一行
//----------------------------------------------------------------------------
TsmTdrRow *tsm_tdr_row_first_i(TsmTdrHandle *a_pHandle);

//============================================================================
// 一些说明
//----------------------------------------------------------------------------
// TSM TDR API 的目的是在不同进程中共享数据，可以共享的数据有两种
// 
//     1 元数据 meta
//           一个 meta 存在于一个 metalib中
//           一般 metalib作为一个整体发布到系统中
//           系统通过 libname，metaname，version 区分不同的元数据
//           元数据一旦发布，就不能删除
// 
//     2 结构体，这是具体的数据
//           一个结构体发布到系统中，会附带三个属性datauri，metauri和datasize
//           如果 metauri和 datasize 同时存在，这两个属性不能冲突
//           metauri 存在的时候，datasize可以省略，因为从 meta 中可以提取size
//           datasize单独存在时，系统之外的的进程可以看到这个结构体
//               但是只知道结构体的尺寸不知道这个结构体的格式，这叫做匿名发布
//----------------------------------------------------------------------------


//----------------------------------------------------------------------------
// THE END
//============================================================================
#endif
